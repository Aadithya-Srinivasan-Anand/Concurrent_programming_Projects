# Alogrithm for parallel quick sort and merge sort using fork join

Program goals: The focus of the program is to sort a file of integers using parallel algorithm and store the sorted integers into a new output file. The code uses quick sort and bucket sort algorithms using fork join and locks based on the input provided, along with the number of threads. It includes a makefile which runs the code

## Quick sort
One of the main things that is required as per the quick sort algorithm is to partition/breakdown the input array using recursuion, so that all elements less than pivot is on one side. this done through `breakdown()` and `quick_sort()` methods. Here the use of multiple threads can be used to parallellize quick sort by dividing them into each chucks/blocks and then combining them. There are two places we apply multithreading. The first time we divide the array into chunks equal to the number of threads. Few chunks may be uneven. We fork and pass one chunk for each thread. Each thread performs quick sort for their chunk. Main thread handles one chunk. We join and wait for all the threads to finish their sorting. The next multithreading is applied to combine these sorted array chunks. The combine is parallelized such that every 2 chunks are taken by a thread and merged. The combined chunks are then further combined with the “combined” chunks from the other threads. these are done in `parallel_quick_sort()` and the `combine_two()` and `combine_k()` functions repectively.

## Bucket sort
The main function of the bucket sort is to keep adding elements in the array to different specified buckets in such a way that each of the bucket is sorted. The sorted buckets are then merged into a fully sorted array. The key of multithreading in bucket sort is to parallelize by dividing the array into chuncks and concurrently adding elements into their sorted buckets as done using the fucntion `bucket_sort()` Each bucket is a priority queue so that the elements added to them are sorted. An array of priority queues is used to handle all the buckets. The sort is parallelized such that we divide the array into chunks equal to the number of threads. Few chunks may be uneven. We fork and pass one chunk for each thread. Each thread adds the element in it to the respective bucket. Concurrency while adding is handled using an array of locks. The number of locks is equal to the number of buckets. Any thread adding to a particular bucket acquires the lock adds the element and then releases the lock. Main thread also handles one chunk of the array. Finally, the buckets are combined to obtain the fully sorted array.
